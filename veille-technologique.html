---
layout: page
title: "Veille Technologique"
nav_order: 5
---

<h1>Veille Technologique</h1>
<p>
    La veille technologique est un processus essentiel permettant d’anticiper les évolutions et innovations dans un domaine donné. 
    Dans le cadre de mon BTS SIO option SLAM, elle me permet de suivre les avancées technologiques en développement web et
    en cybersécurité, afin d’améliorer mes compétences et d’optimiser les solutions que je développe.
</p>
<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°1 : Laravel</h2>
  
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette technologie ?</strong><br>
    Nous avons découvert Laravel en voulant un framework PHP 
    rapide à prendre en main et très structuré. Cette technologie 
    nous intéressait pour gérer facilement l’authentification, la 
    sécurisation des routes et la création de modèles (ORM Eloquent).
  </p>
  
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Documentation officielle de Laravel (<a href="https://laravel.com/docs">laravel.com/docs</a>)<br>
    • Tutoriels vidéo sur YouTube (chaînes francophones sur Laravel)<br>
    • Articles OpenClassrooms et blogs tech sur l’architecture MVC<br>
    • Forums comme Stack Overflow pour résoudre des erreurs spécifiques
  </p>
  
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Comment mettre en place une base de données via les migrations Laravel<br>
    • Gestion des routes et création de contrôleurs pour séparer logiques métier et affichage<br>
    • Utilisation de l’ORM Eloquent pour manipuler plus facilement les données<br>
    • Configuration de Composer et des dépendances pour un projet Laravel
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°2 : Spring Boot</h2>
  
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette technologie;?</strong><br>
    Dans le cadre de RFTG, nous avions besoin d’un <em>backend</em> Java 
    robuste et rapide à mettre en place. Spring Boot s’est avéré idéal, car il 
    simplifie la configuration et la création d’une API REST.
  </p>
  
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées&nbsp;:</strong><br>
    • Documentation officielle Spring (<a href="https://spring.io/projects/spring-boot" target="_blank">spring.io</a>)<br>
    • Tutoriels vidéo YouTube (déploiement, mise en place de REST Controllers)<br>
    • Articles sur l’architecture microservices et la sécurité (Spring Security)<br>
    • Forums comme Stack Overflow pour résoudre des erreurs spécifiques
  </p>
  
  <p>
    <strong>Ce que j’ai appris&nbsp;:</strong><br>
    • Comment configurer rapidement un projet Java avec Spring Initializr<br>
    • Création de contrôleurs REST et utilisation d’annotations comme <code>@RestController</code><br>
    • Gestion de la persistance (Spring Data JPA) et mapping objet‐relationnel<br>
    • Bonnes pratiques autour de la sécurité des endpoints et du déploiement (Tomcat ou autre)
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°3 : Android Studio & Processus Asynchrone</h2>
  
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette techno ?</strong><br>
    Durant la réalisation de l’application mobile RFTG, nous avons rencontré la problématique 
    de gérer des tâches en arrière-plan (téléchargement de données, appels réseau) sans bloquer 
    l’interface. Android Studio, combiné à des mécanismes d’exécution asynchrone, nous a permis 
    de maintenir une application fluide et réactive.
  </p>
  
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Documentation officielle d’Android (section <em>Threads &amp; Async Tasks</em>)<br>
    • Tutoriels YouTube sur l’utilisation des <code>AsyncTask</code> (versions plus anciennes) 
      et des <em>coroutines</em> Kotlin<br>
    • Blogs et articles sur <em>LiveData</em>, <em>ViewModel</em> et l’architecture MVVM 
      (pour une approche plus moderne)<br>
    • Forums Stack Overflow pour la gestion des <em>handlers</em> et des <em>runnables</em>
  </p>
  
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • L’importance d’effectuer les opérations longues (connexion réseau, accès à la BDD) dans 
      un thread distinct du thread principal pour éviter de figer l’UI<br>
    • Les bases des coroutines Kotlin (suspend functions, <code>GlobalScope.launch</code>, 
      etc.) pour un code asynchrone plus lisible et moins “callback‐hell”<br>
    • Comment utiliser des composants d’architecture (ViewModel, LiveData) pour observer 
      l’état de l’application sans bloquer l’interface<br>
    • Les bonnes pratiques pour synchroniser l’UI après une tâche asynchrone et mettre à jour 
      l’affichage en toute sécurité
  </p>
</section>


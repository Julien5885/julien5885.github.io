---
layout: page
title: "Veille Technologique"
nav_order: 5
---

<h1>Veille Technologique Définition </h1>
<p>
    La veille technologique est un processus essentiel permettant d’anticiper les évolutions et innovations dans un domaine donné. 
    Dans le cadre de mon BTS SIO option SLAM, elle me permet de suivre les avancées technologiques en développement web et
    en cybersécurité, afin d’améliorer mes compétences et d’optimiser les solutions que je développe.
</p>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°1 : Laravel</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette technologie ?</strong><br>
    Laravel a été utilisé pour développer le front-end de l'application web Mario. Il s’agit d’un framework PHP moderne, structuré selon le modèle MVC, qui facilite l’organisation du code et la communication avec des APIs REST. Grâce à Blade, TailwindCSS et Guzzle, nous avons conçu une interface fluide, sécurisée et connectée au back-end Spring Boot.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Documentation officielle Laravel (<a href="https://laravel.com/docs">laravel.com/docs</a>)<br>
    • Tutoriels YouTube<br>
    • Articles OpenClassrooms<br>
    • OpenAI (avec vérification des sources)
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Utilisation de Blade pour les vues<br>
    • Appels HTTP avec Guzzle<br>
    • Intégration TailwindCSS<br>
    • Gestion de l’authentification via la table staff<br>
    • Utilisation des migrations Laravel (lorsque compatible avec la BDD)
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°2 : Spring Boot</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette technologie ?</strong><br>
    Spring Boot a été choisi pour créer le back-end du projet RFTG (Mario + Luigi). Il permet de développer rapidement des APIs REST fiables, en Java, avec une structure claire. Nous avons codé manuellement dans VS Code, sans utiliser Spring Initializr, en structurant les contrôleurs pour gérer les entités comme film, inventory, rental.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Documentation Spring Boot (<a href="https://spring.io/projects/spring-boot" target="_blank">spring.io</a>)<br>
    • Tutoriels vidéo YouTube<br>
    • OpenAI pour des explications ciblées
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Structuration manuelle d’un projet Java sous VS Code<br>
    • Création d’API REST (GET, POST...) avec @RestController<br>
    • Configuration Maven et mapping des entités<br>
    • Traçage des erreurs via logs Java<br>
    • Respect strict de la structure imposée (aucune modification du backend possible)
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°3 : Android Studio & Processus Asynchrone</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette technologie ?</strong><br>
    L’application mobile Luigi devait être fluide et responsive. Pour cela, les appels aux webservices Spring Boot (comme /rental/add) devaient être réalisés en arrière-plan, sans bloquer l’interface. D’où l’importance des Threads Java pour l’exécution asynchrone.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Documentation officielle Android (AsyncTask, Threads)<br>
    • Tutoriels YouTube sur les appels réseau<br>
    • Blogs sur ViewModel, LiveData, gestion du panier<br>
    • Stack Overflow pour des cas concrets de gestion du contexte UI
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Exécuter des appels API dans des Threads<br>
    • Utiliser ArrayList&lt;Integer&gt; pour stocker les filmId<br>
    • Associer dynamiquement un filmId à son titre<br>
    • Afficher et synchroniser l’interface après réponse API<br>
    • Rendre l’URL d’appel configurable dynamiquement via Intent
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°4 : Bug Bounty & YesWeHack</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette approche ?</strong><br>
    Le bug bounty est une méthode encadrée pour identifier et signaler des failles de sécurité sur des sites web. YesWeHack propose une plateforme légale pour apprendre, tester et collaborer avec des entreprises. J’ai pu expérimenter la recherche de failles comme XSS, IDOR, ou open redirect.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • YesWeHack (<a href="https://yeswehack.com" target="_blank">yeswehack.com</a>)<br>
    • OWASP Top 10<br>
    • Tutoriels YouTube HackerOne/YesWeHack<br>
    • Outils Burp Suite, ZAP, scripts Python pour la phase de reconnaissance
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Définir un scope précis de test<br>
    • Rechercher automatiquement des endpoints vulnérables<br>
    • Exécuter des attaques contrôlées (ex : injection, IDOR)<br>
    • Rédiger un rapport d’exploitation (preuve, impact, recommandation)<br>
    • Collaborer dans un cadre légal et professionnel
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°5 : Kali Linux</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cette distribution ?</strong><br>
    Kali Linux est une distribution spécialisée pour l’audit de sécurité. Elle contient les outils nécessaires pour scanner, analyser et tester des systèmes ou applications web. Je l’ai utilisée en environnement virtuel pour tester en toute sécurité.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • Site officiel (<a href="https://www.kali.org" target="_blank">kali.org</a>)<br>
    • Tutoriels YouTube (installation, Nmap, Metasploit)<br>
    • Forums Kali Linux et Reddit
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Installer Kali en VM et le sécuriser<br>
    • Utiliser des outils comme Nmap, Nikto, Metasploit<br>
    • Réaliser des scans de ports ou de vulnérabilités<br>
    • Créer un environnement d’audit sans risques
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°6 : Burp Suite</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cet outil ?</strong><br>
    Burp Suite est un outil incontournable pour intercepter et analyser les requêtes web. Il permet d’identifier rapidement des failles comme XSS ou injections SQL. Je l’ai utilisé dans mes tests sur des formulaires web, et pour observer les comportements de l’API.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • PortSwigger (<a href="https://portswigger.net/burp" target="_blank">portswigger.net</a>)<br>
    • YouTube (config proxy, replay requêtes)<br>
    • OWASP Testing Guide
  </p>
  <p>
    <strong>Ce que j’ai appris :</strong><br>
    • Intercepter et modifier les requêtes en direct<br>
    • Utiliser Repeater pour tester des valeurs dangereuses<br>
    • Comprendre la structure HTTP des formulaires<br>
    • Comparer les limites de la version Free vs Pro
  </p>
</section>

<section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°7 : OWASP ZAP (Zed Attack Proxy)</h2>
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cet outil ?</strong><br>
    ZAP est un proxy open-source similaire à Burp, mais gratuit. Je l’ai utilisé pour automatiser la recherche d’URLs et tester leur sécurité. Il s’intègre bien dans une démarche DevSecOps et peut être scripté pour des tests en continu.
  </p>
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées :</strong><br>
    • OWASP ZAP (<a href="https://www.zaproxy.org" target="_blank">zaproxy.org</a>)<br>
    • Tutoriels sur les spiders et alertes<br>
    • Forums GitHub OWASP ZAP
  </p>
  <section style="margin-bottom: 2rem;">
  <h2 style="margin-bottom: 1rem;">Veille n°7 : OWASP ZAP (Zed Attack Proxy)</h2>
  
  <p style="margin-bottom: 1rem;">
    <strong>Pourquoi cet outil&nbsp;?</strong><br>
    OWASP ZAP est un outil d’analyse de sécurité web, utilisé comme alternative open source à Burp Suite. Il est intégré directement dans la distribution Kali Linux, ce qui permet de l’utiliser rapidement dans un environnement dédié aux tests d’intrusion. J’ai utilisé ZAP pour scanner des sites web et identifier des failles potentielles dans un cadre pédagogique.
  </p>
  
  <p style="margin-bottom: 1rem;">
    <strong>Ressources consultées&nbsp;:</strong><br>
    • Documentation officielle OWASP ZAP (<a href="https://www.zaproxy.org" target="_blank">zaproxy.org</a>)<br>
    • Tutoriels YouTube (configuration, scans, interprétation des alertes)<br>
    • Kali Linux + forums OWASP<br>
    • OWASP Testing Guide (méthodologie d’audit)
  </p>
  
  <p style="margin-bottom: 1rem;">
    <strong>Ce que j’ai appris&nbsp;:</strong><br>
    • Lancer un spider (robot d’exploration) pour détecter toutes les pages d’un site web<br>
    • Exécuter un scan passif pour détecter les vulnérabilités sans interagir<br>
    • Déclencher un scan actif (attaque contrôlée) pour tester des failles comme XSS, SQLi, ou inclusion de fichiers<br>
    • Lire les résultats dans l’onglet “Alerts” : chaque alerte est classée par niveau (Low, Medium, High) avec une description du problème, des preuves (ex : requêtes/réponses) et des recommandations
  </p>  
  <p>
    <strong>Perspectives&nbsp;:</strong><br>
    ZAP m’a permis de comprendre concrètement comment un site peut être analysé automatiquement. Je prévois de l’intégrer dans un workflow plus automatisé, par exemple en l’associant à des scripts Python ou à un pipeline CI/CD, pour détecter des failles dès le développement d’un site.
  </p>
</section>
</section>
